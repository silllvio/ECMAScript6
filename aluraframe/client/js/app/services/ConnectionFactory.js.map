{"version":3,"sources":["../../app-es6/services/ConnectionFactory.js"],"names":["ConnectionFactory","stores","version","dbName","connection","close","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onupgradeneeded","_createStores","e","target","result","onsuccess","bind","onerror","error","name","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;AACA;AACA,IAAIA,oBAAqB,YAAY;;AAEjC;AACA,QAAMC,SAAS,CAAC,aAAD,CAAf;AACA,QAAMC,UAAU,CAAhB;AACA,QAAMC,SAAS,YAAf;;AAEA,QAAIC,aAAa,IAAjB;AACA,QAAIC,QAAQ,IAAZ;;AAEA;AAEI,qCAAc;AAAA;;AACV,kBAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAJL;AAAA;AAAA,4CAM2B;;AAEnB,uBAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC;AACA,wBAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBV,MAAtB,EAA8BD,OAA9B,CAAlB;;AAEA;AACAQ,gCAAYI,eAAZ,GAA8B,aAAK;;AAE/Bd,0CAAkBe,aAAlB,CAAgCC,EAAEC,MAAF,CAASC,MAAzC,EAF+B,CAEmB;AAErD,qBAJD;;AAMA;AACA;AACAR,gCAAYS,SAAZ,GAAwB,aAAK;;AAEzB;AACA,4BAAI,CAACf,UAAL,EAAiB;AACbA,yCAAaY,EAAEC,MAAF,CAASC,MAAtB;;AAEA;AACAb,oCAAQD,WAAWC,KAAX,CAAiBe,IAAjB,CAAsBhB,UAAtB,CAAR,CAJa,CAI8B;AAC3CA,uCAAWC,KAAX,GAAmB,YAAY;AAC3B,sCAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AACH,6BAFD;AAGH;AACDE,gCAAQJ,UAAR;AACH,qBAbD;;AAeA;AACAM,gCAAYW,OAAZ,GAAsB;AAAA,+BAAKZ,OAAOO,EAAEC,MAAF,CAASK,KAAT,CAAeC,IAAtB,CAAL;AAAA,qBAAtB;AACH,iBA/BM,CAAP;AAgCH;AAxCL;AAAA;AAAA,0CA0CyBnB,UA1CzB,EA0CqC;;AAE7B;AACA;AACAH,uBAAOuB,OAAP,CAAe,iBAAS;AACpB,wBAAIpB,WAAWqB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAJ,EACIvB,WAAWwB,iBAAX,CAA6BD,KAA7B,EAFgB,CAEoB;;AAExCvB,+BAAWyB,iBAAX,CAA6BF,KAA7B,EAAoC,EAAEG,eAAe,IAAjB,EAApC;AAEH,iBAND;AAQH;AAtDL;AAAA;AAAA,8CAwD6B;AACrB,oBAAI1B,UAAJ,EAAgB;AACZ;AACA;AACAC,4BAHY,CAGH;AACTD,iCAAa,IAAb;AACH;AACJ;AA/DL;;AAAA;AAAA;;AAmEA;;;;;;AAQH,CArFuB,EAAxB,C,CAqFK","file":"ConnectionFactory.js","sourcesContent":["\r\n// MobiliPaterner -- transforma todo o script em um módulo.\r\nvar ConnectionFactory = (function () {\r\n\r\n    // Criando variáveis státicas. Essas ainda não existem no ECMASricpt6.\r\n    const stores = ['negociacoes'];\r\n    const version = 7;\r\n    const dbName = 'aluraframe';\r\n\r\n    var connection = null;\r\n    var close = null;\r\n\r\n    return class ConnectionFactory {\r\n\r\n        constructor() {\r\n            throw new Error('Não é possível instanciar a classe ConnectionFactory');\r\n        }\r\n\r\n        static getConnection() {\r\n\r\n            return new Promise((resolve, reject) => {\r\n\r\n                // Abrindo a conexão com o banco.\r\n                let openRequest = window.indexedDB.open(dbName, version);\r\n\r\n                // Criando uma conexão.\r\n                openRequest.onupgradeneeded = e => {\r\n\r\n                    ConnectionFactory._createStores(e.target.result); // Cria a connection.\r\n\r\n                };\r\n\r\n                // Quando está tudo ok é quando recebemos a conexão para trabalhar.\r\n                // Devolvendo a variável da promise. Que é a própria conexão.\r\n                openRequest.onsuccess = e => {\r\n\r\n                    // verifica se a se connection está nulo, se tiver cria uma conexão se não mantém a mesma.\r\n                    if (!connection) {\r\n                        connection = e.target.result;\r\n\r\n                        //Monkey pating.\r\n                        close = connection.close.bind(connection); // Já criamos a associação na hora da cópia.\r\n                        connection.close = function () {\r\n                            throw new Error('você não pode fechar diretamente a conexão.');\r\n                        };\r\n                    }\r\n                    resolve(connection);\r\n                };\r\n\r\n                // Devolve a string do erro e não o objeto erro.\r\n                openRequest.onerror = e => reject(e.target.error.name);\r\n            });\r\n        };\r\n\r\n        static _createStores(connection) {\r\n\r\n            // varrendo todas as stores e limpado caso já existam.\r\n            // Dropa a objectStore caso ela já exista.\r\n            stores.forEach(store => {\r\n                if (connection.objectStoreNames.contains(store))\r\n                    connection.deleteObjectStore(store);// não precisa do bloquinho de fechamento.\r\n\r\n                connection.createObjectStore(store, { autoIncrement: true });\r\n\r\n            });\r\n\r\n        };\r\n\r\n        static closeConnection() {\r\n            if (connection) {\r\n                // podemos usar a api de reflaction \r\n                // Reflect.apply(close,connection,[]);\r\n                close(); // O this desse close é a própria connectin por conta do bind que colocamos na hora da cópia.\r\n                connection = null;\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    /*\r\n        A avaliação de uma variável será nulo quando:\r\n        0\r\n        null\r\n        undefined\r\n    */\r\n\r\n\r\n})() // Função anônima autoinvocada."]}